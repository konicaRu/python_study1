# Разблокировка мобильных телефонов
# Код блокировки мобильных телефонов не умеют взламывать даже спецслужбы, однако хакерская группировка Анонимусы-80
# добралась до исходников операционной системы, и выяснила способ его почти мгновенного взлома.
#
# Оказывается, достаточно лишь посчитать длину линии, рисуемой в процессе взлома кода, после чего округлить её до
# пятого знака, и нажать пальцем на соответствующие цифры, пропуская нули, как телефон разблокируется.
#
# Раскладка точек блокировки:
# [[6, 1, 9],
# [5, 2, 8],
# [4, 3, 7]]
# Ломаная линия разброкировки представляет собой последовательность цифр от 1 до 9, соответствующих точкам на этой картинке, причем гарантируется, что от точки переход совершается только к её ближайшим соседям (нету перепрыгиваний, например из точки 8 в точку 5).
# Расстояние между точками по вертикали или горизонтали считается единичным.
#
# На рисунке представлена такая последовательность: 1 2 3 4 5 6 2 7 8 9
#
# Её длина приблизительно равняется 1 + 1 + 1 + 1 + 1 + 1.41.. + 1.41.. + 1 + 1 = 9.82842
# (точность требуется пять цифр после запятой)
#
# Результат: строка "982842"
#
# Если бы результат получился, например, 10.012, то результирующая строка получилась бы "112" (все нули удаляются).
#
# Функция
#
# string PatternUnlock(int N, int [] hits)
# получает параметром N длину массива с кодами разблокировки, а сам массив hits содержит последовательность кодов разблокировки -- номера точек в диапазоне от 1 до 9.
# Возвращает функция строку, как в примере выше.

def PatternUnlock(N, hits):
    dial = [[6, 1, 9], [5, 2, 8], [4, 3, 7]]  # создаем двумерный массив, симулирующий клавиатуру
    keeper = []
    sum = 0
    res = ''
    for i in range(len(hits)):
        if hits[i] == hits[
            -1]:  # заглушка , когда перебор дойдет до последней цифры массива hits проверку остановить и вывести результат
            break
        for j in range(len(dial)):
            for k in range(len(dial[j])):  # сначала проверяем совпадение следующего числа из массива с предидущим
                if hits[i] == dial[j][k] and 0 <= k - 1 <= 2 and dial[j][k - 1] == hits[i + 1]:
                    keeper.append(1)  # по горизонтали и вертикали при соппадении загоняем в новый массив кипер 1
                    # не забываем ставить границы чтобы поиск не выскочил за пределы массива
                if hits[i] == dial[j][k] and 0 <= j + 1 <= 2 and dial[j + 1][k] == hits[i + 1]:
                    keeper.append(1)
                if hits[i] == dial[j][k] and 0 <= k + 1 <= 2 and dial[j][k + 1] == hits[i + 1]:
                    keeper.append(1)
                if hits[i] == dial[j][k] and 0 <= j - 1 <= 2 and dial[j - 1][k] == hits[i + 1]:
                    keeper.append(1)
                # потом проверяем по диагонали при совпадении загоняем в массив 1.41421
                if hits[i] == dial[j][k] and 0 <= j - 1 <= 2 and 0 <= k - 1 <= 2 and dial[j - 1][k - 1] == hits[i + 1]:
                    keeper.append(1.41421)
                if hits[i] == dial[j][k] and 0 <= j - 1 <= 2 and 0 <= k + 1 <= 2 and dial[j - 1][k + 1] == hits[i + 1]:
                    keeper.append(1.41421)
                if hits[i] == dial[j][k] and 0 <= j + 1 <= 2 and 0 <= k + 1 <= 2 and dial[j + 1][k + 1] == hits[i + 1]:
                    keeper.append(1.41421)
                if hits[i] == dial[j][k] and 0 <= j + 1 <= 2 and 0 <= k - 1 <= 2 and dial[j + 1][k - 1] == hits[i + 1]:
                    keeper.append(1.41421)
    for i in keeper:
        sum += i
    sum = float('{:.5f}'.format(sum)) # перебираем массив оставляем 5 знаков после запятой
    sum = str(sum)# делаем строку
    for i in sum:
        if i != '0' and i != '.': # перебираем строку и склеиваем коктенацией исключая ноль и точку
            res += i
    return res
