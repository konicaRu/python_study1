# В этом разделе находяться решения небольших задач которые я решал изучая  Python
## Например:
### Оптимизация беспилотного трафика
Яндекс выпускает на улицы тысячи беспилотных автомобилей, и теперь появляется отличная возможность оптимизации трафика на дорогах.
Прежде всего требуется точно оценить время
прибытия машины в место назначения.
На дороге автомобиль постоянно встречает
светофоры, которые горят либо зелёным, либо
красным. Время горения зелёного и красного
света задаётся в секундах. Цикл переключения
цветов повторяется бесконечно и начинается с
красного цвета.
Так как скорость автомобиля известна,
положения светофоров на дороге определяются
временем, которое требуется, чтобы доехать до
этого светофора из начала дороги при условии,
что все предыдущие светофоры горят зелёным.
Каждый светофор также характеризуется
временем горения красного и зелёного цвета.

**Задача** -- определить, за какое время автомобиль
доберётся до конца дороги.

Например, имеется дорога длиной 10 единиц
времени.

Первый светофор расположен на
отметке 3 единицы времени и характеризуется
циклом 5 красный 5 зелёный. 

Второй светофор
расположен на отметке 5, и время показа
красного и зелёного для него 2 и 2.

Автомобиль стартует, через 3 единицы
добирается до первого светофора, на котором
горит красный. Он горит 5 единиц, то есть
движение начинается с 5-го момента.
Через две единицы автомобиль добирается до
второго светофора -- это абсолютный момент 7. 

В этот момент на светофоре горит зелёный, и
автомобиль проезжает его без остановвки. От
второго светофора до конца дороги остаётся ещё
5 моментов, таким образом суммарное время
автомобиля в пути равно 12 (7 + 5).

Функция
**int Unmanned(int L, int N, int [][3] track)**
получает на вход длину L дороги, количество
светофоров на ней N, и описание самой дороги,
где каждый элемент состоит из трёх значений:
момент времени относительно начала дороги,
когда в него прибудет автомобиль по свободной
дороге, время показа красного света и время
показа зелёного цвета.

Для примера выше параметры функции
**Unmanned()** будут такими: **10, 2, [ [3,5,5], [5,2,2] ]**
Функция возвращает реальное время, требуемое
для преодоления дороги.

## Код решения:
``` 
def Unmanned(L, N, track):    
    color = ''  
    dist_gen = 0    
    gen_count = 0  # общий счетчик ходов
    for k in range(len(track)):  # отрезков действия столько сколько светофоров
        time_light = 0  # счетчик горения светофора? обнуляем при переходе к след светофору
        wait_time = 0  # время ожидания на светофоре
        time_drive = 0
        while True:
            time_drive += 1
            gen_count += 1
            time_light += 1  # сначала загорается красный
            if time_light > track[k][1] + track[k][2]:  # зацикливаем бесконечное горение светоф
                time_light = 1
            if time_light <= track[k][1]:
                color = 'red'  # то горит красный
            if time_light > track[k][1] and time_light <= track[k][1] + track[k][2]:
                color = 'green'
            if color == 'green' and k == 0 and len(track) > 1:
                dist_gen = track[k][0] + wait_time + (track[k + 1][0] - track[k][0])
                break
            if gen_count > track[k][0] and color == 'red' and k == 0:  # k==0 заглушка для работы только на 1 светофоре
                wait_time += 1  # необходимо сделать чтобы было 2
            if time_drive > dist_gen and color == 'red' and k > 0:
                wait_time += 1
            if time_drive >= dist_gen and color == 'green' and k < len(track) - 1:
                dist_gen = dist_gen + wait_time + (track[k + 1][0] - track[k][0])
                break
            if time_drive >= dist_gen and color == 'green' and k == len(track) - 1 and len(track)>1:
                dist_gen = dist_gen + wait_time + (L - track[k][0])
                return dist_gen
            if color == 'green' and len(track) == 1:
                dist_gen = track[k][0] + wait_time + (L - track[k][0])
                return dist_gen

